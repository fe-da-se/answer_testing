# 1. Уровни тестирования.

## 1. Модульное тестирование (Unit Testing)

*Цель: Верификация отдельных модулей (функции/методы/классы)*

*Объект: Отдельные части кода*

*Особенности: Может выполняться разработчиками с помощью фреймворков, зависимости заменяются на mocks/stubs*

## 2. Интеграционное тестирование (Integration Testing)

*Цель: Проверка взаимодействия между модулями*

*Объект: Интерфейс и передача данных между модулями/компонентами*

*Особенности: Проводится после модульного тестирования, возможны подходы Big Bang или Incremental (крупное обновление/постепенное обновление)*

## 3. Системное тестировние (System Testing)

*Цель: Валидация системы на соответствие требованиям*

*Объект: Интегрированная система в реальных условиях*

*Особенности: Включает функциональные, нагрузочные, security-тесты*

## 4. Приёмочное тестирование (Acceptance Testing)

*Цель: Подтверждения соответсвия системы ожидания заказчика*

*Объект: Роботоспособность в реальном использовании*

*Особенности: Проводиться заказчиком или представителями, представляя собой альфа- и бета-тестирование*

---

# 2. Модульное тестирование. В чём разница, когда применять для достижения наибольшей эффективности. 

**Модульное тестрование** - это тестирование отдельных компонентов кода по типу модулей/функций/классов. 

Главной особенностью данного тестирования это возможность делать его самому разработчику и легко автоматизировать с помощью `unit-тестов` используя инструменты фреймворков и библиотек специально написанных для этого.

Данное тестирование применяется как на ранних стадиях разработки, так и на более поздних. Применение на любой стадии позволяет проверить базовой функциональности, быстрое выявления деффектов в изолированных блоках и проверка критических функций. 

Премущества:

- Быстрое обнаружение на ранних этапах

- Быстрое выполнение и простота

- Минимизация рисков появления багов при измении кода

Недостатки:

- Не проверяет взаимодействие между модулями

- Требуется время на написания тестов и заглушек

---
# 3. Что такое пирамида тестирования? Какие уровни в неё входят? 

**Пирамида тестирования** - это модель предложенная Майком Коном в 2009 году, которая включает в себя:

1. **Модульное тестирование (Unit Tests)** - проверка отдельных частей кода (функций/методов/классов)
	
2.  **Сервисные тесты (Service Tests)** - проверка взаимодействия между компонентами.
	
3. **Тесты пользовательского интерфейса (UI Tests)** - провека системы через интерфейс.

В наше время данная пирамида в подобном виде не используется, но является основой для кастомизации.

## Уровни:

1. **Модульное тестирование (Unit Testing)** - верификция отдельных модулей (изолированных строк кода), может испольняться самим разработчиком с помощью библиотек и фреймворков и заглушками (mocks/stubs).
	
2. **Интеграционное тестирование (Integration Testing)** - проверка взаимодействия между модулями/компонентами, проводиться после модульного тестирования и имеет возможность подходов Big Bang и Incremental (крупных изменений и постепенных изменений)
	
3. **Системное тестирование (System Testing)** - валидация системы на соответсвия требований, полная проверка системы в реальных условиях использования, может в себя включать функциональные, нагрузочные и security-тесты.
	
4. **Приёмочное тестирование (Acceptance Testing)** - проверка системы заказчиком или его представителем, которое включает в себя альфа- и бета-тестирование.  

## Ключевые принципы:

- Тестируй всё на своём уровне, одни тесты не должны лезть в другие. 

	- `Unit-тесты` не должны копаться в API, а `UI-тесты` копаться в функциях.
	
- Выше - не значит глубже.  
	
	- `UI-тесты` - не проверяют не логику модулей, а результат.

- Чем выше - тем дороже.
	
	- `Unit-тесты` пистать быстрее и дешевле, `UI-тесты` долго и дороже.

- Наверху - бизнес-критичное.
	
	- Баги в `UI` могут нанести больше финансовый и репутационный ущерб.

---

# 4.  Что такое интеграционное тестирование? Какие существуют уровни и подходы к интеграционному тестированию. 

**Интеграционное тестирование** - проверка взаимодействия между модулями/компонентами.

## Уровни: 

1. **Компонентный** - проверка взаимодействие внутри компонента одной системы.

2. **Системный** - проверка взаимодействия подсистем внутри системы. 

3. **Интеграционный** - проверка взаимодействия системы со стронними сервисами.  

## Подходы:

- **Снизу-Вверх (Bottom-Up)** - проверка начинанется с низкоуровневых модулей, потом добавляются верхние слои.
	
	- *Плюсы:*
		- *Быстрая проверка основы системы.* 
		- *Легко найти баг.* 
	
	- *Минусы:* 
		- *`UI` тестируется в конце из-за чего можно упустить некоторые проблемы. **

- **Сверху-Вниз (Top-Down)** - проверка начинается с `UI`, а нижние слои заменяются заглушками. Постепенно идёт подключения дополнительных модулей логики.
	
	- *Плюсы:*
		- *С самого начала видно как пользователь может взаимодействовать с системой.* 
		- *Наблюдаем проблемы `UI` (интерфейса/дизайна).*
	- *Минусы:*
		- *Написание заглушек.*

- **Большой взрыв (Big Bang)** - полная сборка и тестирование проекта.
	
	- *Плюсы:*
		- *Не требуется подготовка, можно сразу приступать к тестированию.*
	- *Минусы:*
		- *Сложный поиск деффектов, тяжело найти компонент/модуль/функцию из-за которой происходит проблема.*

- **Гибридный (Sandwich)** - начинаем тестирование с бизнес-логики, а `UI` и логику заглушками (mock).

	- *Плюсы:*
		- *Баланс скорости и точности.*
		- *Фокус на ключевом.*
	- *Минусы:*
		- *Сложнее планировать.*

- **Инкрементальное** - добавляем модули поэтапно и проверяем их на каждом шаге.
	
	- *Плюсы:*
		- *Быстрое нахождение ошибок.*
		- *Отладка проще.*
	- *Минусы:*
		- *Долго планировать порядок.*

## Задачи:

- *Поиск багов на стыках.*

- *Провека целостности.*

- *Проверка производительности.*

- *Проверка безопасности.*

- *Провека совместимости*

---

# 5. Чем отличается интеграция внутри системы от интеграции со смежными системами?

Интеграция — это процесс объединения различных компонентов информационной инфраструктуры для обмена информацией и совместной работы. Она делится на два основных типа: **интеграцию внутри системы** и **интеграцию со смежными системами**. Рассмотрим основные различия между ними:

## Интеграция внутри системы

Этот тип интеграции предполагает объединение отдельных модулей или подсистем одной и той же корпоративной информационной системы (ИС). Примеры включают интеграцию ERP-системы (Enterprise Resource Planning), CRM-системы (Customer Relationship Management) и бухгалтерской программы одного предприятия.

## Особенности внутренней интеграции:

- **Единое информационное пространство**: Все компоненты принадлежат единой организации и используют общую базу данных или систему хранения данных.
- **Совместимость технологий**: Обычно используется один стек технологий разработки, что упрощает обмен данными и минимизирует технические сложности.
- **Контроль безопасности**: Доступ к данным контролируется единым механизмом авторизации и аутентификации, что повышает уровень защищенности.
- **Простота управления**: Единая административная политика позволяет централизованно управлять настройками и обновлениями всех интегрированных компонент.

Примером внутренней интеграции является внедрение модуля расчета заработной платы в существующую ERP-систему крупной российской производственной компании.

---

## Интеграция со смежными системами

Данный вид интеграции подразумевает взаимодействие информационных систем разных организаций, сторонних сервисов или облачных решений. Например, подключение внешнего сервиса электронной отчетности (например, "Сбис") к собственной ИТ-инфраструктуре предприятия.

## Основные характеристики внешней интеграции:

- **Разнородность данных**: Данные поступают из разных источников, использующих различные форматы представления и протоколы передачи.
- **Безопасность**: Необходимо обеспечивать безопасность обмена конфиденциальной информацией между организациями посредством шифрования и строгих протоколов авторизации.
- **Поддержка стандартов**: Для успешной интеграции часто используются общепринятые стандарты и протоколы взаимодействия (например, SOAP, REST API).
- **Адаптация бизнес-процессов**: Часто возникает необходимость адаптации внутренних процессов под требования внешних партнеров.

Пример внешней интеграции — подключение российского банка к государственной платформе "Госуслуги" для предоставления услуг гражданам онлайн.

---

Таким образом, ключевое различие заключается в следующем:

- Внутренняя интеграция объединяет модули одной системы, тогда как внешняя интеграция обеспечивает связь между разными независимыми системами.
- Внешняя интеграция требует учета большего количества технических аспектов и вопросов безопасности, поскольку приходится взаимодействовать с посторонними источниками данных.

Эти отличия влияют на сложность реализации, затраты ресурсов и выбор подходов к проектированию и управлению системой интеграции.

---

# 6. Когда применяется системное тестирование? Какие подходы используются в системном тестировании? 

**Системное тестирование** - это тестирование всего проекта, всех его модулей.

## Когда применяется:

1. *После завершения модульного и интеграционного тестирования.*
2. *Когда система собрана и полностью готова к комплексной проверке.*
3. *Перед передачей проекта на приёмочное тестирование (альфа-/бета-тестирование).*
4. *В рамках регрессионного тестирования.*
5. *На стадии предварительной эксплуатации.*

## Что проверяется:

-  *Функциональность*
- *Производительность*
- *Совместимость*
- *Удобства использования*
- *Безопасность*
- *Реакция на сбои*

## Подготовка:

- *Анализ требований*: 
	- *Убедиться, что все функциональные и нефункциональные требования были детально описаны. 
	- *Создайте матрицу трассировки требований для покрытия каждого требования тестами. 
	
- *Подготовка тестовой документации:*
	- *Подготовка тест-плана, тест-кейсов и т.п.*
	
- *Использование реальных данных:*
	- *Используйте подходящие данные, которые бы использовал обычный пользователь, начиная от типа данных и заканчивая их объёмом.*
	
- *Тестирование в реальных условиях:*
	- *Проводите тестирование максимально приближенному к реальному пользовательскому опыту.*
	
- *Автоматизация повторяющихся тестов:*
	- *Автоматизируйте регрессионные, нагрузочные и производительные тесты для удобвства и корректности проверок.*
	
- *Кроссбраузерность и кроссплатформенность:*
	- *Используйте для тестирования различные конфигурации системы и ПО.*
	
- *Приоритетное тестирование:*
	- *Начните тестирование с критических функций.*
	
- *Использование различных техник тест-дизайна:*
	- *В тестировании одной системы используйте различные подходы к её тестированию по типу `парного тестирования`, `анализ граничных значений` и прочие.*
	
- *Проведение стресс-тестирования:*
	- *Проверка системы в условиях превышающих допустимую нагрузку.*
	
- *Оценка времени восстановления:*
	- *Проверка как быстро система восставналивается после различных сбоев.*

## Подходы:

1. **Ручное тестирование (Manual Testing)** - проверка сложных пользовательских сценариев.
2. **Автоматизированное тестирование (Automated Testing)** - автоматизация рутинных задач.
3. **Смешанное тестирование** - комбинация ручного и автоматизированного.
4. **Тестирование чёрным ящиком (Black-Box Testing)** - тестирование внешнего поведения системы без представления о внутренней логике проекта. 
5. **Тестирование белым ящиком (White-Box Testing)** - тестирование внутренней логики системы, зная что она из себя представляет.
6. **Тестирование серым ящиком (Grey-Box Testing)** - тестирование комбинированным подходом ящиков, но тестировщик имеет только частичный доступ к логике системы.
7. **Smoke-тестирование** - быстрое тестирование основного функционала при каждой сборке проекта.
8. **Sanity-тестирование** - тестирование конкретного изменения
9. **Exploratory-тестирование** - исследовательское тестирование без каких-либо подготовок и сценариев.
10. **Тестирование на основе Uses Cases** - проверка реальных сценариев использования ПО.

## Методология:

- *Анализ продукта*
- *Разработка тестирования*
- *Создание тест-кейсов*
- *Настройка сетевого окружения*
- *Выполнение тестов*
- *Анализ результатов*
- *Ретестинг и регрессивное тестирование*

## Риски: 

- *Неверное понимание требований - составьте чётки требования и согласуйте их с командой*
- *Нефункциональные требования - включение в тестирование проверку безопасности, производительности и отказаустойчивости.*
- *Неполное покрытие тестами - использование различных техник тест-дизайна.*
- *Зависимоть от окружения - проводить тесты в разных конфигурациях.*
- *Проблемы с восстановлением после сбоев - проверка отказаустройчивости.*

## Виды тестов в рамках системного тестирования:

1. **Функциональные** - проверка основных функций.
2. **Нефункциональные** - проверка производительности, безопасности, удобства, совместимости.
3. **Отказ и восстановление** - симуляции высоких нагрузок и скорости восстановления.
4. **Конфигурационное** - проверка работы с разными конфигурациями ПО.
5. **Объёмное** - проверка работы с большим объёмом данных.
6. **Стабильностное** - проверка стабильности системы/проверка длительной работоспособности системы.

---

# 7. Что такое функциональное тестирование? Когда и в каких аспектах его следует применять? Какие существуют виды функционального тестирования?

**Функциональное тестирование** - это проверка того, _что_ делает программное обеспечение, а не _как_. Оно основывается на требованиях: тестировщик берёт спецификацию и проверяет, что каждая функция работает так, как задумано. 

## Когда применять?

Функциональное тестирование используется:

- **На всех уровнях разработки**: от отдельных модулей до всей системы.
    
- **Перед релизом**: чтобы убедиться, что основные функции работают.
    
- **После изменений**: чтобы проверить, что новый код не поломал старый (регрессия).

## Виды:

- **Модульное (Unit testing)** — тестирование отдельного куска кода (обычно делают разработчики).
    
- **Компонентное (Component testing)** — проверка работы компонента целиком.
    
- **Интеграционное** — проверка связей между компонентами/модулями.
    
- **Системное (System testing)** — тестирование всей системы в сборе.
    
- **Приёмочное (Acceptance testing)** — проверка, устраивает ли продукт конечного пользователя или заказчика.
    
- **Регрессионное** — убедиться, что новое изменение не сломало старый функционал.
    
- **Smoke (Дымовое)** — быстрая проверка, «жива» ли система.
    
- **Sanity (Санитарная)** — быстрая проверка отдельных функций после изменений.
    
- **End-to-End (E2E)** — проверка длинных пользовательских сценариев «от начала до конца».
    
- **Тестирование взаимодействия (Interoperability)** — проверка работы с внешними системами.
    
- **Исследовательское (Exploratory)** — без чётких шагов, больше опираясь на опыт.
    
- **Ad-hoc** — хаотичная проверка «на глаз», без документации и планов.


---

# 8. Что такое тестирование взаимодействия? Когда его применять для минимизации рисков? 

**Тестирование взаимодействия** — это проверка корректности обмена данными и совместной работы между различными модулями, системами или сервисами.

## Когда применять:

- При интеграции модулей в единую систему.
    
- При подключении сторонних API или сервисов.
    
- Перед выходом системы в эксплуатацию, чтобы убедиться, что все подсистемы корректно взаимодействуют.
    
- В проектах, где важна целостность данных (банковские системы, медицина, госуслуги).
    

## Цель:

- Минимизировать риски, связанные с потерей или искажением данных.
    
- Проверить корректность протоколов и форматов обмена.
    
- Убедиться в правильности бизнес-логики при передаче данных между компонентами.
---
# 9. Какие бывают нефункциональные виды тестирования? Когда их стоит применять?

**Нефункциональное тестирование** проверяет не то, _что_ делает система, а _как_ она это делает.

## Основные виды:

1. **Тестирование производительности (Performance Testing)** — проверка скорости работы.
    
2. **Нагрузочное (Load Testing)** — проверка при высокой нагрузке.
    
3. **Стрессовое (Stress Testing)** — проверка за пределами допустимой нагрузки.
    
4. **Тестирование стабильности (Stability/Soak Testing)** — проверка длительной работы системы.
    
5. **Тестирование безопасности (Security Testing)** — проверка защиты данных и уязвимостей.
    
6. **Тестирование удобства использования (Usability Testing)** — насколько удобно работать пользователю.
    
7. **Тестирование совместимости (Compatibility Testing)** — работа в разных ОС, браузерах, устройствах.
    
8. **Конфигурационное тестирование (Configuration Testing)** — проверка разных вариантов окружений.
    

## Когда применять:

- После функционального тестирования.
    
- Перед релизом, чтобы проверить готовность системы к реальным условиям.
    
- На критичных этапах (финансовые операции, массовые сервисы).
---

# 10. Какие существуют виды производительности? Каковы цели и сферы применения каждого из них? 

**Тестирование производительности** — часть нефункционального тестирования, цель которого — оценить, как система справляется с нагрузкой.

## Виды:

1. **Load Testing (Нагрузочное)**
    
    - Проверка работы системы при ожидаемой нагрузке.
        
    - Цель: убедиться, что система справляется с обычным сценарием.
        
2. **Stress Testing (Стрессовое)**
    
    - Проверка системы за пределами нормы.
        
    - Цель: определить пределы отказа и поведение при сбоях.
        
3. **Spike Testing (Пиковое)**
    
    - Резкий скачок нагрузки.
        
    - Цель: оценить реакцию на внезапный рост пользователей.
        
4. **Endurance/Soak Testing (Длительное)**
    
    - Тест длительной работы под нагрузкой.
        
    - Цель: выявить утечки памяти, деградацию производительности.
        
5. **Scalability Testing (Масштабируемость)**
    
    - Проверка, насколько легко система масштабируется.
        
    - Цель: понять, можно ли увеличить мощности без сбоев.
        
6. **Volume Testing (Объёмное)**
    
    - Проверка работы с большими объёмами данных.
        
    - Цель: выявить ограничения базы данных и системы хранения.

---

# 11. Как проводится тестирования установки в веб-тестировании? Какие особенности и цели тестирования установки? Что проверяется при тестировании установки? Как обеспечивается кроссплатформенность?

### Как проводится тестирование установки в веб-тестировании?

Веб-приложения обычно не требуют «классической установки», как десктопные программы. Но тестирование установки здесь включает проверку:

- правильности **развёртывания приложения** на сервере;
    
- доступности сайта/сервиса по нужному адресу;
    
- корректной работы при **первом запуске**;
    
- наличия и установки **необходимых зависимостей** (например, браузерные плагины, сертификаты).
    

---

### Цели тестирования установки

- Убедиться, что приложение можно **правильно развернуть** на сервере и оно доступно пользователю.
    
- Проверить, что **процесс установки понятен и не вызывает ошибок**.
    
- Подтвердить, что при обновлении сохраняются нужные данные и не ломается существующая функциональность.
    
- Обеспечить **удобство первого использования** (чтобы пользователь без проблем вошёл в систему и начал работу).
    

---

### Что проверяется при тестировании установки?

1. **Корректность процесса установки/развёртывания**: нет ошибок, нужные файлы загружаются.
    
2. **Минимальные требования**: поддержка нужных браузеров, ОС, подключение к базе данных.
    
3. **Сценарии обновления**: работает ли приложение после новой версии.
    
4. **Сценарии удаления**: корректное удаление временных файлов, кэша, лишних зависимостей.
    
5. **Поведение при сбое**: что произойдёт, если установка прервана.
    

---

### Как обеспечивается кроссплатформенность?

- Тестирование приложения в **разных браузерах** (Chrome, Firefox, Safari, Edge).
    
- Проверка работы на **разных ОС** (Windows, macOS, Linux, Android, iOS).
    
- Использование **виртуальных машин и эмуляторов** для проверки окружений.
    
- Применение инструментов типа BrowserStack, Sauce Labs для удалённого тестирования.


---
# 12. Что такое UI-тестирование? Какие уровни проведения UI-тестирования существуют? Какие параметры оцениваются при UI-тестировании?

### Что такое UI-тестирование?

**UI-тестирование (User Interface Testing)** — это проверка **пользовательского интерфейса**: насколько элементы (кнопки, поля, меню, формы) работают правильно, удобно и соответствуют требованиям дизайна/юзабилити.

Главная цель — убедиться, что пользователь может **легко и корректно взаимодействовать** с приложением.

---

### Уровни проведения UI-тестирования

1. **На уровне отдельных элементов** — проверка кнопок, форм, ссылок, выпадающих списков.
    
2. **На уровне экранов/страниц** — тестирование связности элементов на одной странице (логика навигации, переходы).
    
3. **На уровне сценариев** — полное прохождение пользовательских историй (например, регистрация + вход + покупка).
    

---

### Какие параметры оцениваются при UI-тестировании?

- **Функциональность**: работают ли элементы так, как задумано (кнопка отправки действительно отправляет).
    
- **Внешний вид (дизайн)**: шрифты, цвета, выравнивание, соответствие макету.
    
- **Юзабилити**: удобство использования, понятность интерфейса.
    
- **Навигация**: логичность расположения кнопок и переходов.
    
- **Согласованность**: единый стиль по всему приложению (иконки, кнопки одинакового типа ведут себя одинаково).
    
- **Адаптивность и кроссбраузерность**: корректность отображения на разных устройствах, размерах экранов и браузерах.
    
- **Производительность UI**: скорость отклика на действия пользователя.

---
# 13. Что такое конфигурационное тестирование в сфере веб-тестирования?

**Конфигурационное тестирование** — это проверка работы веб-приложения в разных окружениях.

## Особенности:

- Проверяется работа в разных **браузерах** (Chrome, Firefox, Safari).
    
- Разные **операционные системы** (Windows, macOS, Linux).
    
- Разные **устройства** (мобильные, планшеты, десктопы).
    
- Разные **сети** (Wi-Fi, 4G, медленный интернет).
    
- Разные **версии библиотек и зависимостей**.
    

## Цель:

- Убедиться, что система одинаково корректно работает в любой поддерживаемой конфигурации.
    
- Минимизировать риск, что у пользователя с «другим браузером» приложение «сломается».

----
# 14. Какие уровни и порядок проведения конфигурационного тестирования?

## Уровни:

1. **Браузерное тестирование** — проверка работы приложения в разных браузерах (Chrome, Firefox, Safari, Edge).
    
2. **Операционные системы** — проверка на Windows, macOS, Linux и мобильных ОС.
    
3. **Устройства** — десктопы, ноутбуки, планшеты, смартфоны.
    
4. **Сети и соединения** — разные скорости интернета (Wi-Fi, 3G/4G/5G, медленный канал).
    
5. **Версии ПО и библиотек** — проверка на разных версиях зависимостей (например, разных версиях Java, .NET, Node.js).
    

## Порядок проведения:

1. Определить **поддерживаемые конфигурации** (список браузеров, устройств, ОС).
    
2. Составить **чек-лист** для каждой конфигурации.
    
3. Выполнить тесты на приоритетных окружениях.
    
4. Сравнить результаты: где приложение работает корректно, а где есть проблемы.
    
5. Задокументировать баги и передать их на исправление.

---
# 15. Что такое регрессионное тестирование? 

**Регрессионное тестирование** — это проверка того, что изменения (фиксы, новые функции) **не сломали старый функционал**.

## Когда применяется:

- После фиксов багов.
    
- После добавления новой функциональности.
    
- Перед релизом (чтобы убедиться, что всё работает как раньше).
    

## Особенности:

- Может быть ручным или автоматизированным.
    
- Чаще всего строится на **автоматизации**, потому что нужно проверять одни и те же сценарии много раз.

---
# 16. Что такое sanity-тестирование?

**Sanity-тестирование** — это **узкая проверка** внесённых изменений в системе.

## Цель:

- Проверить, что конкретное исправление или доработка работает корректно.
    
- Убедиться, что изменение не повлияло на ключевой функционал, связанный с ним.
---
# 17. Что такое smoke-тестирование?

**Smoke-тестирование** (от англ. «дым») — это быстрая проверка базовой работоспособности системы.

## Цель:

- Убедиться, что сборка вообще запускается и не «дымится».
    
- Проверить самые важные функции (логин, открытие страниц, базовые операции).
    

## Когда используется:

- При каждой новой сборке.
    
- Перед более глубоким тестированием (чтобы не тратить время на «мертвую» систему).
    

💡 Разница со **sanity**:

- _Smoke_ — проверяем «жив ли проект вообще».
    
- _Sanity_ — проверяем конкретное изменение.

---
# 18. В чём разница между статическим и динамическим тестированием? Какие методы относятся к каждому из них?

## 1. **Статическое тестирование**

- Выполняется **без запуска кода**.
    
- Проверка документации, требований, дизайна, архитектуры.
    
- Методы: ревью, инспекции, анализ кода, верификация требований.
    
- Цель: найти ошибки ещё до разработки/запуска.
    

## 2. **Динамическое тестирование**

- Выполняется **с запуском кода**.
    
- Проверка функционала, производительности, UI, интеграций.
    
- Методы: black-box, white-box, тест-кейсы, автоматизация.
    
- Цель: убедиться, что система работает правильно при выполнении.
---
# 19. В чём суть подходов "чёрного", "белого" и "серого" ящика? Какие виды тестирования относятся к каждому из подходов? 

## 1. **Black Box (чёрный ящик)**

- Тестировщик **не знает внутреннюю логику кода**.
    
- Проверяется только ввод и вывод (input → output).
    
- Виды: функциональное тестирование, приёмочное, системное, UI-тесты.
    

## 2. **White Box (белый ящик)**

- Тестировщик **знает внутреннюю структуру кода**.
    
- Проверяются алгоритмы, условия, циклы, покрытие кода.
    
- Виды: модульное тестирование, unit-тесты, тестирование безопасности (на уровне кода).
    

## 3. **Grey Box (серый ящик)**

- Тестировщик знает **часть внутренней логики**, но работает в основном как в black box.
    
- Используется для интеграционного тестирования, API-тестов, безопасности.
    
- Позволяет сочетать пользовательский и технический взгляд.

---

# 20. Что такое тестовая стратегия, тест-план, тест-кейс, чек-лист, баг-репорт?

## 1. Тестовая стратегия (Test Strategy)

**Тестовая стратегия** - это высокоуровневый документ, который содержит общую информацию по тестированию проекта.

В составлении документа могут участвовать QA-менеджер, бизнес-аналитик, менеджер проекта.

*НЕ СУЩЕСТВУЕТ УНИВЕРСАЛЬНОГО ШАБЛОНА*

Подходы к написанию стратегий могут быть разными, в зависимости от контекста продукта и проекта. Стратегия говорит нам о подходах к тестированию продукта в целом, на всех этапах его жизненного цикла.

### Тестовая стратегия содержит ответы на следующие вопросы:

- Какие техники тестирования будут применяться?
    
- Какие модули будут протестированы?
    
- Какие критерии входа и выхода?
    
- Какая область тестирования?
    
- Какая степень автоматизации процессов?
    
- Какие человеческие и другие ресурсы будут задействованы?

### Может быть также включена следующая информация:

- Анализ рисков,
    
- Контроль релизов,
    
- Инструменты тестирования,
    
- Встраивание Quality Gates,
    
- Общие рекомендации по написанию тестовых кейсов,
    
- Отчетность по тестированию,
    
    И др.

### Тестовую стратегию невозможно сформировать без входных документов, таких как:

- Документация дизайна системы,
    
- Может понадобится документ по релизной политике и другие второстепенные документы.

## 2. Тестовый план (Test Plane)

**Тестовый план** - это документ описывающий весь объём работ, начиная с описания ПО, критериев тестирования, расписания и заканчивая необходимого оборудования, ПО, знаний. 

### Виды тестового плана:

- **Мастер** - статичен, содержит в себе высокоуровневую информацию, которая не подвержена частому изменению. В формальном виде может отсутствовать в проетке. 
	
- **Детальный** - динамичен, содержит информацию о том что, как, кем и в какие сроки  будет протестировано на конкретном этапе. Постоянно претерпевает изменения. 
	
- **План приемочных испытаний** – описывает стратегию приемочного тестирования (если оно необходимо). 

## 3. Тест кейс (Test Case)

**Тест кейс** - это алгоритм/последовательность действий, который выполняет тестировщик по отношению к ПО, где подробно прописаны шаги (подготовка к тесту, проверка и ожидаемый результат). 

Если фактический результат тестирования соответствует ожидаемому, то всё хорошо, иначе: 

- Если проблема в программе - составить bug-report (отчёт об ошибке)
	
- Если в тест кейсе - исправить самому
	
- Если в стенде - сообщить техническим специалистам 

### Виды тест кейсов:

- **Позитивные/положительные** - проверка системы на корректные данные. К примеру корретный введённый email или дата (в email присутствует знак `@`, а в дате указана реальная дата, а не набор символов)
	
- **Негативные/отрицательные** - проверка системы на некорректные данные. К примеру реакция системы на некорретно введённую почту или дату.
	
- **Деструктивный** - проверка системы на прочность методами различных хакерских атак. К примеру `SQL-инъекции` (метод при котором в поле отправки данных прописываются `SQL-код`, который может выполняться на сервере.  

### Атрибуты:

- **Уникальный номер** - любая нумерация принятая на проекте.
	
- **Заголовок** - краткое описание задачи.
	
- **Предусловие** - условие перед началом тестирование.
	
- **Окружение** - устройство или программа в которой выполнялось тестирование.
	
- **Шаги** - последовательность тестирования.
	
- **Ожидаемый рузельтат** - то, что тестировщик должен получить во время или после теста. 
	
- **Статус** - текущий этап тестирования, выбор вариантов, которые были заранее определены командой.
	
- **Фактический результат** - то, что получилось после выполнения всех шагов, часто может не записываться, поскольку результат описывают `bug-report` в случае failed.

### Правила составления тест-кейсов:

1. Заголовок должен быть чётким, лаконичным и выражающим суть проверки. В него не нужно добавлять шаги тест-кейса.
	
2. В предусловии важно описать состояние системы, которое нужно для выполнения шагов тест-кейса. Например, там могут быть конкретные ссылки на среды, где проводятся тестирования. Или на документы, которые понадобятся для прохождения шагов.
	
3. Шаги тест-кейса не нужно описывать слишком подробно. Например, следует писать «Введите email» вместо «Введите email, нажимая клавиши на клавиатуре».
	
4. Шаги не должны быть размытыми или абстрактными. Нельзя сказать «Зайдите в раздел «Магазин» — лучше указать путь к нему, если он не слишком очевиден.
	
5. Скриншоты лучше использовать только как дополнение к словесному описанию, но не в качестве его замены.

### Дополнение: 

- **Детализация Тест Кейсов (Test Case Specification)** - это уровень детализации описания тестовых шагов и требуемого результата, при котором обеспечивается разумное соотношение времени прохождения к тестовому покрытию
	
- **Время Прохождения Тест Кейса (Test Case Pass Time) - это время от начала прохождения шагов тест кейса до получения результата теста.** 

## 4. Чек-лист (Check List) 

**Чек-лист** - это структурированный список проверок, который содержит ключевые аспекты системы, но не содержит детализированных инструкций при выполнении. 

### *💡Примечание:*

*Чек-лист это не упрощённый тест-кейс, они должны дополнять друг друга. Чек-лист можно использовать для быстрой проверки, а потом проходить по тест-кейсам.*

## 5. Баг-репорт (Bug Report)

**Баг-репорт** - это документ, который содержит ошибку и последовательность действий приведший к ней.

---
# 21. Как составить тест-кейс, чек-лист и баг-репорт?

**Тест-кейс (Test Case)**

1. **Заголовок** — кратко, что проверяем.
    
2. **Предусловие** — что должно быть подготовлено до теста.
    
3. **Шаги** — последовательность действий тестировщика.
    
4. **Ожидаемый результат** — что должно произойти.
    
5. **Фактический результат** — что произошло на самом деле.
    
6. **Статус** — Passed/Failed.
    

**Чек-лист (Check List)**

- Структурированный список проверок без детальных инструкций.
    
- Используется для быстрого контроля ключевых функций.
    

**Баг-репорт (Bug Report)**

1. **Заголовок** — кратко о проблеме.
    
2. **Описание** — что произошло, шаги для воспроизведения.
    
3. **Ожидаемый результат** vs **Фактический результат**.
    
4. **Серьёзность/Приоритет**.

---
# 22. Каков жизненный цикл бага? Какие статусы проходит баг от обнаружения до закрытия?

**Жизненный цикл бага** — путь ошибки от обнаружения до закрытия.  
**Статусы:**

1. **New (Новый)** — баг обнаружен.
    
2. **Assigned (Назначен)** — назначен разработчику.
    
3. **Open (В работе)** — разработчик работает над исправлением.
    
4. **Fixed (Исправлен)** — баг исправлен.
    
5. **Retest (Проверка)** — тестировщик проверяет исправление.
    
6. **Verified (Проверен)** — баг подтверждён как исправленный.
    
7. **Closed (Закрыт)** — баг закрыт, исправление принято.
    
8. **Reopened (Переоткрыт)** — если ошибка осталась или воспроизвелась снова.

---
# 23. Что такое тестирование классами эквивалентности? Как его применять на практике?

**Суть:** делим данные на группы (классы), где элементы ведут себя одинаково.  
**Применение на практике:**

- Например, поле «Возраст 1–100».
    
- Классы: валидные 1–100, невалидные <1, >100, пустое.
    
- Тестируем один пример из каждого класса вместо всех возможных значений.

---
# 24. Что такое тестирование граничных значений? Почему это важно?

**Суть:** проверка **крайних значений** диапазона, где чаще всего ошибки.

- Пример: поле «Возраст 1–100» → тестируем 1, 100, 0, 101.  
    **Важность:** помогает ловить ошибки на границах, где логика часто ломается.

---
# 25. Что такое таблица принятия решений? Как она используется при составлении тест-кейсов?

- Таблица, где перечислены **условия и действия системы**.
    
- Используется для тест-кейсов, чтобы покрыть все возможные комбинации входных данных.
    
- Пример: кнопка «Отправить» активна, если все поля заполнены. Таблица показывает все комбинации заполнения полей и ожидаемый результат.

---
# 26. Что представляет собой диаграмма состояний? Как использовать её при тестировании? 

- Отображает все **состояния объекта и переходы между ними**.
    
- Используется для тестирования логики, когда система меняет состояние в зависимости от действий пользователя.
    
- Пример: статус заказа → «Новый» → «В обработке» → «Отправлен» → «Доставлен». Тестируем, что все переходы корректны.

---
# 27. Что такое попарное тестирование? Каковы его премущества?

- Метод, где проверяются **все возможные пары значений параметров**, вместо всех комбинаций.
    
- Преимущество: сокращает количество тестов, но при этом покрывает большинство ошибок, связанных с взаимодействием двух параметров.
    
- Пример: браузер (Chrome, Firefox) × ОС (Windows, Mac) → тестируем все пары, не все возможные тройки.

---

# 28. В чём разница между верификацией и валидацией?

**Верификация (Verification)** - это процесс оценки ПО по требованиям.

**Валидация (Validation)** - это определение соответствия по потребностям пользователей.

---

# 29. Что такое аутефикация и авторизация?

**Идентификация** - определение пользователя.
**Аутефикация** - подтверждение подлинности.
**Авторизация** - проверка и предоставления прав.

---
# 30. Какие бывают типы логов в системе?

Логи — это записи о событиях в системе, которые помогают отслеживать работу приложения и находить ошибки. Основные типы:

1. **Системные логи** — информация о работе ОС или серверов (запуск, завершение процессов, ошибки оборудования).
    
2. **Приложенческие логи** — события, связанные с работой самого приложения (вход пользователя, действия, ошибки).
    
3. **Безопасности/Аудита** — кто, когда и какие действия выполнял (важно для безопасности).
    
4. **Транзакционные** — записи операций с данными (например, оплата, изменение базы данных).
    
5. **Дебаг/Отладочные** — подробная информация для разработчиков при тестировании и исправлении багов.

---
# 31. Какие существуют уровни логирования?

Уровни помогают фильтровать важность сообщений в логах. Основные:

1. **TRACE** — максимально подробные данные для отладки.
    
2. **DEBUG** — подробная информация для разработчиков о работе системы.
    
3. **INFO** — общие события, важные, но не ошибки (например, успешный вход пользователя).
    
4. **WARN** — предупреждения, которые не критичны, но могут привести к проблемам.
    
5. **ERROR** — ошибки, которые влияют на работу приложения.
    
6. **FATAL / CRITICAL** — критические ошибки, из-за которых система может перестать работать.

---